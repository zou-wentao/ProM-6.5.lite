/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. query.jj */
/*@egen*//*
 * Some parts of this file have been copied from JavaCC.jj under the following license:
 *
 * Copyright (c) 2006, Sun Microsystems, Inc.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Sun Microsystems, Inc. nor the names of its
 *       contributors may be used to endorse or promote products derived from
 *       this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

options
{
	STATIC=false;
	                       
	                    
	             
	           
}
PARSER_BEGIN(QueryParser)
package org.processmining.xeslite.query.syntax;

import java.io.StringReader;

public class QueryParser/*@bgen(jjtree)*/implements QueryParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTQueryParserState jjtree = new JJTQueryParserState();

/*@egen*/

    public QueryParser(String s) {
        this(new StringReader(s)); 
    }
    
}
PARSER_END(QueryParser)

SKIP :                              
{
    " "
    | "\t"
    | "\r"
    | "\n"

}

TOKEN [IGNORE_CASE]:
{
      <AND: "and">
   |  <OR:  "or">
   |  <LPAREN: "(">
   |  <RPAREN: ")">
   |  <EQUAL: "=">
   |  <CONTAINS: "%">
   |  <REGEX: "~">
   |  <NOTEQUAL: "!=">
   |  <GT: ">">
   |  <LT: "<">
   |  <LTE: "<=">
   |  <GTE: ">=">
   |  <DOT: ".">
}

/* JAVA LITERALS (from original JavaCC.jj project)*/

TOKEN :
{
  < INTEGER_LITERAL:
      ("-")?
      (  
      	<DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
      )
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
|
  < FLOATING_POINT_LITERAL:
  	  ("-")?
  	  (
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]
      )
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
}


/* IDENTIFIER (adapted from JavaCC.jj) */

TOKEN :
{  
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>|<SPECIALCHAR>)* >
| < #LETTER:
      [
       "$",
       "A"-"Z",
       "_",
       "a"-"z",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"       
      ]
  >
| < #DIGIT:
      [
       "0"-"9",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ]
  >
| < #SPECIALCHAR:
 	  [
 	  	":",
 	  	"#",
 	  	"@",
 	  	",",
 	  	"_",
 	  	"-",
 	  	"|",
 	  	"&",
 	  	"^",
 	  	"$",
 	  	"#",
 	  	"@",
 	  	"+",
 	  	"*"
 	  ]
  >
}

<*> TOKEN : { <UNKNOWN: ~[]> }


QueryRoot parse()       :
{/*@bgen(jjtree) Root */
  QueryRoot jjtn000 = new QueryRoot(JJTROOT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) Root */
    try {
/*@egen*/
    orExpression() <EOF>/*@bgen(jjtree)*/
                         {
                           jjtree.closeNodeScope(jjtn000, true);
                           jjtc000 = false;
                         }
/*@egen*/ {return jjtn000;}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void orExpression() :
{	
}
{           
	andExpression()
	(/*@bgen(jjtree) #BinaryLogicalExpression( 2) */
                {
                  QueryBinaryLogicalExpression jjtn001 = new QueryBinaryLogicalExpression(JJTBINARYLOGICALEXPRESSION);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
                }
                try {
/*@egen*/							
		( jjtn001.op = <OR>.image andExpression())/*@bgen(jjtree)*/
                } catch (Throwable jjte001) {
                  if (jjtc001) {
                    jjtree.clearNodeScope(jjtn001);
                    jjtc001 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte001 instanceof RuntimeException) {
                    throw (RuntimeException)jjte001;
                  }
                  if (jjte001 instanceof ParseException) {
                    throw (ParseException)jjte001;
                  }
                  throw (Error)jjte001;
                } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001,  2);
                  }
                }
/*@egen*/                            
	)*
}

void andExpression() :
{
}
{           
	term()
	(/*@bgen(jjtree) #BinaryLogicalExpression( 2) */
                {
                  QueryBinaryLogicalExpression jjtn001 = new QueryBinaryLogicalExpression(JJTBINARYLOGICALEXPRESSION);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
                }
                try {
/*@egen*/							
		( jjtn001.op = <AND>.image term())/*@bgen(jjtree)*/
                } catch (Throwable jjte001) {
                  if (jjtc001) {
                    jjtree.clearNodeScope(jjtn001);
                    jjtc001 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte001 instanceof RuntimeException) {
                    throw (RuntimeException)jjte001;
                  }
                  if (jjte001 instanceof ParseException) {
                    throw (ParseException)jjte001;
                  }
                  throw (Error)jjte001;
                } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001,  2);
                  }
                }
/*@egen*/                            
	)*
}

void term() :
{
}
{
	simpleExpression()
    |    
    (<LPAREN> orExpression() <RPAREN>)
}

void simpleExpression()                   : 
{/*@bgen(jjtree) SimpleExpression */
  QuerySimpleExpression jjtn000 = new QuerySimpleExpression(JJTSIMPLEEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
}
{/*@bgen(jjtree) SimpleExpression */
        try {
/*@egen*/	
	( LOOKAHEAD(2) eventName() <DOT> )?	
   	attributeName()
   	(
   	 	jjtn000.op = op()
   	)    	
	value()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void eventName()       : 
{/*@bgen(jjtree) Atom */
        QueryAtom jjtn000 = new QueryAtom(JJTATOM);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token val;
}
{/*@bgen(jjtree) Atom */
        try {
/*@egen*/
	(
		val = <IDENTIFIER>/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                        }
/*@egen*/ 
			{
				jjtn000.val = val.image;
			} 
		| 
		val = <STRING_LITERAL>/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                        }
/*@egen*/
			{     
             jjtn000.val = val.image.substring(1, val.image.length() - 1);
         	}		
	)/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/	
}

void attributeName()       : 
{/*@bgen(jjtree) Atom */
        QueryAtom jjtn000 = new QueryAtom(JJTATOM);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token val;
}
{/*@bgen(jjtree) Atom */
        try {
/*@egen*/
	(
		val = <IDENTIFIER>/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                        }
/*@egen*/ 
			{
				jjtn000.val = val.image;
			} 
		| 
		val = <STRING_LITERAL>/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                        }
/*@egen*/
			{     
             jjtn000.val = val.image.substring(1, val.image.length() - 1);
         	}		
	)/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/	
}

void value()       : 
{/*@bgen(jjtree) Atom */
        QueryAtom jjtn000 = new QueryAtom(JJTATOM);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Token val;
}
{/*@bgen(jjtree) Atom */
        try {
/*@egen*/
	(
		( val = <IDENTIFIER> | val = <INTEGER_LITERAL> | val = <FLOATING_POINT_LITERAL> )/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                        }
/*@egen*/ 
			{
				jjtn000.val = val.image;
			} 
		| 
		val = <STRING_LITERAL>/*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                        }
/*@egen*/
			{     
             jjtn000.val = val.image.substring(1, val.image.length() - 1);
         	}		
	)/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/	
}

String op(): 
{
	Token op;
}
{
( op = <EQUAL> | op = <CONTAINS> | op = <REGEX> | op = <NOTEQUAL> | op = <GT> | op = <LT> | op = <LTE> | op = <GTE>)
	{
		return op.image;
	} 
}